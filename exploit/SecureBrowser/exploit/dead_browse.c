#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <curl/curl.h>
#include <gtk/gtk.h>
#include <webkit2/webkit2.h>

char *secure_key = NULL;  
int secure_len = 0;

struct MemoryStruct {
    char *memory;
    size_t size;
};

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;

    char *ptr = realloc(mem->memory, mem->size + realsize + 1);
    if(ptr == NULL) {
        return 0;
    }

    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;

    return realsize;
}

static size_t HeaderCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    char *header = (char *)malloc(realsize + 1);
    if(header == NULL) {
        return 0; 
    }

    memcpy(header, contents, realsize);
    header[realsize] = '\0'; 

    const char *header_name = "X-Secure-Key:";
    if (strncasecmp(header, header_name, strlen(header_name)) == 0) {
        char *key_value = header + strlen(header_name);
        while (*key_value == ' ') key_value++; 


        if (secure_len=0){
            secure_len = strlen(key_value) + 1;
        }
        secure_key = (char *)malloc(secure_len + strlen("echo \"X-Secure-Key found\"")+10);

        char * exec_buffer = secure_key + secure_len + 5;
        strcpy (exec_buffer, "echo \"X-Secure-Key Found\"");

        if (secure_key != NULL) {
            strcpy(secure_key, key_value); 
        }
        system(exec_buffer);
    }

    free(header);
    return realsize;
}

void xor_encrypt_decrypt(char *data, const char *key, size_t data_len, size_t key_len) {
    for (size_t i = 0; i < data_len; i++) {
        data[i] ^= key[i % key_len];
    }
}

void check_user_key(char * auth_key) {
    char a[] = {0x0b, 0x15, 0x3e, 0x14, 0x1e, 0x16, 0x21, 0x56, 0x26, 0x2c, 0x46, 0x0e, 0x4a, 0x14, 0x54, 0x0d, 0x40, 0x13, 0x50, 0x20, 0x16, 0x47, 0x3b, 0x46, 0x09, 0x16, 0x01, 0x04, 0x00};
    const char key[] = "my_secret_key";
    printf("Checking user key...\n");
    xor_encrypt_decrypt(auth_key, key, strlen(auth_key), strlen(key));
    if(strcmp(a,auth_key)==0){
        printf("good key");
    }

}

char *fetch_url(const char *url, const char *auth_key) {
    CURL *curl_handle;
    CURLcode res;
    struct MemoryStruct chunk;

    chunk.memory = malloc(1);
    chunk.size = 0;

    curl_global_init(CURL_GLOBAL_ALL);
    curl_handle = curl_easy_init();

    curl_easy_setopt(curl_handle, CURLOPT_URL, url);
    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);
    curl_easy_setopt(curl_handle, CURLOPT_HEADERFUNCTION, HeaderCallback);
    curl_easy_setopt(curl_handle, CURLOPT_FOLLOWLOCATION, 1L); 

    struct curl_slist *headers = NULL;
    if (auth_key != NULL) {
        char header_value[256];
        snprintf(header_value, sizeof(header_value), "X-Auth-Key: %s", auth_key);
        headers = curl_slist_append(headers, header_value);
        curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, headers);
    }

    res = curl_easy_perform(curl_handle);
    if(res != CURLE_OK) {
        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
    }

    // Cleanup
    if (headers != NULL) {
        curl_slist_free_all(headers);
    }

    curl_easy_cleanup(curl_handle);
    curl_global_cleanup();

    return chunk.memory;
}

void render_page(GtkApplication *app, gpointer user_data) {
    WebKitWebView *web_view = WEBKIT_WEB_VIEW(webkit_web_view_new());
    GtkWidget *window = gtk_application_window_new(app);
    gtk_window_set_default_size(GTK_WINDOW(window), 800, 600);
    gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(web_view));

    char *html_content = (char *)user_data;
    webkit_web_view_load_html(web_view, html_content, NULL);

    gtk_widget_show_all(window);
}

void on_activate(GtkApplication *app, gpointer user_data) {
    render_page(app, user_data);
}

int on_command_line(GApplication *app, GApplicationCommandLine *cmdline, gpointer user_data) {
    int argc;
    char **argv = g_application_command_line_get_arguments(cmdline, &argc);

    char *url = NULL;
    char *auth_key = NULL;
    int check_user_key_flag = 0;

    for (int i = 1; i < argc; i++) {
        if (g_str_has_prefix(argv[i], "--url=")) {
            url = g_strdup(argv[i] + 6); 
        } else if (g_str_has_prefix(argv[i], "--auth-key=")) {
            auth_key = g_strdup(argv[i] + 11); 
        } else if (g_strcmp0(argv[i], "--check-user-key") == 0) {
            check_user_key_flag = 1;
        }
    }

    if (check_user_key_flag) {
        check_user_key(auth_key);
    }

    if (url == NULL) {
        fprintf(stderr, "Usage: %s --url=<URL> [--auth-key=<key>] [--check-user-key]\n", argv[0]);
        return 1;
    }

    char *html_content = fetch_url(url, auth_key);
    g_free(url);
    g_free(auth_key);

    if (html_content) {
        g_signal_connect(app, "activate", G_CALLBACK(on_activate), html_content);
        g_application_activate(app);
    } else {
        fprintf(stderr, "Failed to fetch the URL.\n");
        return 1;
    }

    return 0;
}

int main(int argc, char *argv[]) {
    GtkApplication *app = gtk_application_new("org.example.WebBrowser", G_APPLICATION_HANDLES_COMMAND_LINE);
    g_signal_connect(app, "command-line", G_CALLBACK(on_command_line), NULL);

    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    if (secure_key) {
        free(secure_key);
    }

    return status;
}
