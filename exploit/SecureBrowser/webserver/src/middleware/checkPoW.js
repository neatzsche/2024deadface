const express = require('express');
const crypto = require('crypto');
const redis = require('redis');
const moment = require('moment');
const redisClient = redis.createClient();
redisClient.connect();

const check_POW = async (req, res, next) => {
    if (!req.body || !req.body.timestamp || !req.body.data || !req.body.powHash) {
        return res.status(400).json({ error: 'Missing required fields' });
    }
    
    const { timestamp, data, nonce, powHash } = req.body;


    const currentTime = moment();
    const requestTime = moment(timestamp);
    if (!requestTime.isValid() || Math.abs(currentTime.diff(requestTime, 'minutes')) > 5) {
        return res.status(400).json({ error: 'Timestamp drift too large or invalid timestamp' });
    }

    //const computedHash = crypto.createHash('sha256').update(data+timestamp+nonce).digest('hex');
    const message = data + timestamp + nonce
    const computedHash = await sha256(message)

    console.log(computedHash)

    if (!computedHash.startsWith('0000')) {
        return res.status(400).json({ error: 'Invalid Proof of Work' });
    }

    if (powHash !== computedHash) {
        return res.status(400).json({ error: 'Provided hash does not match computed hash' });
    }

    const a = await redisClient.get(powHash)
    if(a){
        return res.status(400).json({error: 'hash already used'})
    }

   await redisClient.set(powHash, 'used', 'EX', 300, (err) => {
        if (err) {
            return res.status(500).json({ error: 'Error storing hash in Redis' });
        }
    });
    next();
};

async function sha256(message) {
    const msgBuffer = new TextEncoder().encode(message);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

module.exports = check_POW